// Copyright (C) 2015       Hykem <hykem@hotmail.com>
// Copyright (C) 2022       hitchhikr <charlet.franck@wanadoo.fr>
// Licensed under the terms of the GNU GPL, version 3
// http://www.gnu.org/licenses/gpl-3.0.txt

#include "sign_np.h"

void print_usage()
{
	printf("Usage: PSPPack [-1..5] [-NAME] <input>\n\n");
	printf("[-1..5]: Number of compression passes (default: 5)\n");
	printf("[-NAME]: 5 chars name (or less) to be displayed in the XMB (default: HITCH)\n");
	printf("<input>: A valid PRX file (a packed & signed EBOOT.PBP will be produced from it).\n\n");
}

unsigned char EBOOT_Dats[] =
{
	0x00,0x50,0x42,0x50,0x00,0x00,0x01,0x00,0x28,0x00,0x00,0x00,0x46,0x01,0x00,0x00,
	0x46,0x01,0x00,0x00,0x46,0x01,0x00,0x00,0x46,0x01,0x00,0x00,0x46,0x01,0x00,0x00,
	0x46,0x01,0x00,0x00,0xf6,0x06,0x00,0x00,0x00,0x50,0x53,0x46,0x01,0x01,0x00,0x00,
	0x94,0x00,0x00,0x00,0xe8,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x04,0x04,
	0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x09,0x00,0x04,0x02,
	0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x12,0x00,0x04,0x02,
	0x0a,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x1a,0x00,0x04,0x02,
	0x05,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x27,0x00,0x04,0x04,
	0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x36,0x00,0x04,0x02,
	0x05,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x24,0x00,0x00,0x00,0x45,0x00,0x04,0x04,
	0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,0x4c,0x00,0x04,0x02,
	0x06,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x42,0x4f,0x4f,0x54,
	0x41,0x42,0x4c,0x45,0x00,0x43,0x41,0x54,0x45,0x47,0x4f,0x52,0x59,0x00,0x44,0x49,
	0x53,0x43,0x5f,0x49,0x44,0x00,0x44,0x49,0x53,0x43,0x5f,0x56,0x45,0x52,0x53,0x49,
	0x4f,0x4e,0x00,0x50,0x41,0x52,0x45,0x4e,0x54,0x41,0x4c,0x5f,0x4c,0x45,0x56,0x45,
	0x4c,0x00,0x50,0x53,0x50,0x5f,0x53,0x59,0x53,0x54,0x45,0x4d,0x5f,0x56,0x45,0x52,
	0x00,0x52,0x45,0x47,0x49,0x4f,0x4e,0x00,0x54,0x49,0x54,0x4c,0x45,0x00,0x00,0x00,
	0x01,0x00,0x00,0x00,0x4d,0x47,0x00,0x00,0x55,0x43,0x4a,0x53,0x31,0x30,0x30,0x34,
	0x31,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,0x2e,0x30,0x30,0x00,0x00,0x00,0x00,
	0x01,0x00,0x00,0x00,0x32,0x2e,0x37,0x30,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,
	0x48,0x49,0x54,0x43,0x48,0x00
};

int main(int argc, char *argv[])
{
	int passes = 5;
	int arg = 1;
	int i;
	int j;

	printf("PSPPack v1.4\n");
	printf("Written by hitchhikr of Rebels.\n\n");

	if ((argc <= 1) || (argc > 4))
	{
		print_usage();
		return 1;
	}
	
	for (i = 0; i < 2; i++)
	{
		if (argv[arg][0] == '-')
		{
			if (!argv[arg][1])
			{
				printf("Error: Invalid argument.\n");
				return 1;
			}
			if (argv[arg][1] < '1' || argv[arg][1] > '5')
			{
				j = 0;
				EBOOT_Dats[320] = ' ';
				EBOOT_Dats[321] = ' ';
				EBOOT_Dats[322] = ' ';
				EBOOT_Dats[323] = ' ';
				EBOOT_Dats[324] = ' ';
				while (argv[arg][j + 1])
				{
					EBOOT_Dats[320 + j] = argv[arg][j + 1];
					j++;
					if (j > 5)
					{
						printf("Error: Too many chars in argument.\n");
						return 1;
					}
				}
			}
			else
			{
				passes = atol(&argv[arg][1]);
				if (passes <= 0 || passes > 5)
				{
					printf("Error: Invalid number of passes.\n");
					return 1;
				}
			}
			arg++;
		}
		else
		{
			break;
		}
	}

	// Open files.
	char *elf_name = argv[arg];
	FILE* elf = fopen(elf_name, "rb");
	FILE* bin = fopen("EBOOT.PBP", "wb");
	// Check input file.
	if (elf == NULL)
	{
		printf("ERROR: Please check your input file!\n");
		fclose(elf);
		fclose(bin);
		return 1;
	}
		
	// Check output file.
	if (bin == NULL)
	{
		printf("ERROR: Please check your output file!\n");
		fclose(elf);
		fclose(bin);
		return 1;
	}
		
	// Get ELF size.
	fseek(elf, 0, SEEK_END);
	int elf_size = ftell(elf);
	fseek(elf, 0, SEEK_SET);

	// Initialize KIRK.
	kirk_init();
	
	// Read ELF file.
	u8 *elf_buf = (u8 *) malloc (elf_size);
	fread(elf_buf, elf_size, 1, elf);
		
	// Sign the ELF file.
	u8 *seboot_buf = (u8 *) malloc (elf_size + 4096);
	memset(seboot_buf, 0, elf_size + 4096);
		
    int seboot_size = sign_eboot(elf_buf, elf_size, passes, seboot_buf);
		
	// Exit in case of error.
	if (seboot_size < 0)
	{
		printf("Error: invalid packed size.\n");
		fclose(elf);
		fclose(bin);
		return 1;
	}

	// Write the signed EBOOT.BIN file.
	u32 *eboot_size = (u32 *) &EBOOT_Dats[36];

	*eboot_size = sizeof(EBOOT_Dats) + seboot_size;
	fwrite(EBOOT_Dats, sizeof(EBOOT_Dats), 1, bin);
	fwrite(seboot_buf, seboot_size, 1, bin);
		
	// Clean up.
	fclose(bin);
	fclose(elf);
	free(seboot_buf);
	free(elf_buf);
		
	printf("EBOOT.PBP created.\n\n");

	printf("Input size: %d bytes\n", elf_size);
	printf("Output size: %d bytes\n", seboot_size + (int) sizeof(EBOOT_Dats));

	return 0;
}
